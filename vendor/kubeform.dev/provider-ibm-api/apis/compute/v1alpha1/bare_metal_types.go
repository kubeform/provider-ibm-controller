/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type BareMetal struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BareMetalSpec   `json:"spec,omitempty"`
	Status            BareMetalStatus `json:"status,omitempty"`
}

type BareMetalSpecStorageGroups struct {
	// Array size of harddrives list
	// +optional
	ArraySize *int64 `json:"arraySize,omitempty" tf:"array_size"`
	// Array type ID
	ArrayTypeID *int64 `json:"arrayTypeID" tf:"array_type_id"`
	// Hard-drives List
	HardDrives []int64 `json:"hardDrives" tf:"hard_drives"`
	// Partition template ID
	// +optional
	PartitionTemplateID *int64 `json:"partitionTemplateID,omitempty" tf:"partition_template_id"`
}

type BareMetalSpec struct {
	State *BareMetalSpecResource `json:"state,omitempty" tf:"-"`

	Resource BareMetalSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`
}

type BareMetalSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// +optional
	BlockStorageIDS []int64 `json:"blockStorageIDS,omitempty" tf:"block_storage_ids"`
	// +optional
	Datacenter *string `json:"datacenter,omitempty" tf:"datacenter"`
	// +optional
	DiskKeyNames []string `json:"diskKeyNames,omitempty" tf:"disk_key_names"`
	// Domain name
	Domain *string `json:"domain" tf:"domain"`
	// +optional
	ExtendedHardwareTesting *bool `json:"extendedHardwareTesting,omitempty" tf:"extended_hardware_testing"`
	// +optional
	FileStorageIDS []int64 `json:"fileStorageIDS,omitempty" tf:"file_storage_ids"`
	// Fixed config preset value
	// +optional
	FixedConfigPreset *string `json:"fixedConfigPreset,omitempty" tf:"fixed_config_preset"`
	// The unique global identifier of the bare metal server
	// +optional
	GlobalIdentifier *string `json:"globalIdentifier,omitempty" tf:"global_identifier"`
	// +optional
	GpuKeyName *string `json:"gpuKeyName,omitempty" tf:"gpu_key_name"`
	// +optional
	GpuSecondaryKeyName *string `json:"gpuSecondaryKeyName,omitempty" tf:"gpu_secondary_key_name"`
	// Host name
	// +optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname"`
	// Enables hourly billing
	// +optional
	HourlyBilling *bool `json:"hourlyBilling,omitempty" tf:"hourly_billing"`
	// OS image template ID
	// +optional
	ImageTemplateID *int64 `json:"imageTemplateID,omitempty" tf:"image_template_id"`
	// +optional
	Ipv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address"`
	// +optional
	Ipv6AddressID *int64 `json:"ipv6AddressID,omitempty" tf:"ipv6_address_id"`
	// Boolean value true if IPV6 ia enabled or false
	// +optional
	Ipv6Enabled *bool `json:"ipv6Enabled,omitempty" tf:"ipv6_enabled"`
	// boolean value true if ipv6 static is enabled else false
	// +optional
	Ipv6StaticEnabled *bool `json:"ipv6StaticEnabled,omitempty" tf:"ipv6_static_enabled"`
	// +optional
	Memory *int64 `json:"memory,omitempty" tf:"memory"`
	// Network speed in MBPS
	// +optional
	NetworkSpeed *int64 `json:"networkSpeed,omitempty" tf:"network_speed"`
	// Optional notes info
	// +optional
	Notes *string `json:"notes,omitempty" tf:"notes"`
	// +optional
	OsKeyName *string `json:"osKeyName,omitempty" tf:"os_key_name"`
	// OS refernece code value
	// +optional
	OsReferenceCode *string `json:"osReferenceCode,omitempty" tf:"os_reference_code"`
	// +optional
	PackageKeyName *string `json:"packageKeyName,omitempty" tf:"package_key_name"`
	// +optional
	PostInstallScriptURI *string `json:"postInstallScriptURI,omitempty" tf:"post_install_script_uri"`
	// +optional
	PrivateIpv4Address *string `json:"privateIpv4Address,omitempty" tf:"private_ipv4_address"`
	// +optional
	PrivateIpv4AddressID *int64 `json:"privateIpv4AddressID,omitempty" tf:"private_ipv4_address_id"`
	// only private network configured if is true
	// +optional
	PrivateNetworkOnly *bool `json:"privateNetworkOnly,omitempty" tf:"private_network_only"`
	// +optional
	PrivateSubnet *string `json:"privateSubnet,omitempty" tf:"private_subnet"`
	// +optional
	PrivateVLANID *int64 `json:"privateVLANID,omitempty" tf:"private_vlan_id"`
	// +optional
	ProcessKeyName *string `json:"processKeyName,omitempty" tf:"process_key_name"`
	// +optional
	PublicBandwidth *int64 `json:"publicBandwidth,omitempty" tf:"public_bandwidth"`
	// +optional
	PublicIpv4Address *string `json:"publicIpv4Address,omitempty" tf:"public_ipv4_address"`
	// +optional
	PublicIpv4AddressID *int64 `json:"publicIpv4AddressID,omitempty" tf:"public_ipv4_address_id"`
	// +optional
	PublicSubnet *string `json:"publicSubnet,omitempty" tf:"public_subnet"`
	// +optional
	PublicVLANID *int64 `json:"publicVLANID,omitempty" tf:"public_vlan_id"`
	// Quote ID for Quote based provisioning
	// +optional
	QuoteID *int64 `json:"quoteID,omitempty" tf:"quote_id"`
	// +optional
	RedundantNetwork *bool `json:"redundantNetwork,omitempty" tf:"redundant_network"`
	// +optional
	RedundantPowerSupply *bool `json:"redundantPowerSupply,omitempty" tf:"redundant_power_supply"`
	// +optional
	RestrictedNetwork *bool `json:"restrictedNetwork,omitempty" tf:"restricted_network"`
	// +optional
	SecondaryIPAddresses []string `json:"secondaryIPAddresses,omitempty" tf:"secondary_ip_addresses"`
	// Secondary IP addresses count
	// +optional
	SecondaryIPCount *int64 `json:"secondaryIPCount,omitempty" tf:"secondary_ip_count"`
	// +optional
	SoftwareGuardExtensions *bool `json:"softwareGuardExtensions,omitempty" tf:"software_guard_extensions"`
	// SSH KEY IDS list
	// +optional
	SshKeyIDS []int64 `json:"sshKeyIDS,omitempty" tf:"ssh_key_ids"`
	// +optional
	StorageGroups []BareMetalSpecStorageGroups `json:"storageGroups,omitempty" tf:"storage_groups"`
	// +optional
	Tags []string `json:"tags,omitempty" tf:"tags"`
	// TCP monitoring enabled if set as true
	// +optional
	TcpMonitoring *bool `json:"tcpMonitoring,omitempty" tf:"tcp_monitoring"`
	// +optional
	UnbondedNetwork *bool `json:"unbondedNetwork,omitempty" tf:"unbonded_network"`
	// User metadata info
	// +optional
	UserMetadata *string `json:"userMetadata,omitempty" tf:"user_metadata"`
}

type BareMetalStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// BareMetalList is a list of BareMetals
type BareMetalList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of BareMetal CRD objects
	Items []BareMetal `json:"items,omitempty"`
}
