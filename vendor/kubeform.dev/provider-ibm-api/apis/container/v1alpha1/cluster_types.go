/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Cluster struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec,omitempty"`
	Status            ClusterStatus `json:"status,omitempty"`
}

type ClusterSpecAlbs struct {
	// +optional
	AlbIP *string `json:"albIP,omitempty" tf:"alb_ip"`
	// +optional
	AlbType *string `json:"albType,omitempty" tf:"alb_type"`
	// +optional
	DisableDeployment *bool `json:"disableDeployment,omitempty" tf:"disable_deployment"`
	// +optional
	Enable *bool `json:"enable,omitempty" tf:"enable"`
	// +optional
	ID *string `json:"ID,omitempty" tf:"id"`
	// +optional
	Name *string `json:"name,omitempty" tf:"name"`
	// +optional
	NumOfInstances *string `json:"numOfInstances,omitempty" tf:"num_of_instances"`
	// +optional
	Resize *bool `json:"resize,omitempty" tf:"resize"`
	// +optional
	State *string `json:"state,omitempty" tf:"state"`
}

type ClusterSpecKmsConfig struct {
	// ID of the customer root key.
	CrkID *string `json:"crkID" tf:"crk_id"`
	// ID of the KMS instance to use to encrypt the cluster.
	InstanceID *string `json:"instanceID" tf:"instance_id"`
	// Specify this option to use the KMS public service endpoint.
	// +optional
	PrivateEndpoint *bool `json:"privateEndpoint,omitempty" tf:"private_endpoint"`
}

type ClusterSpecTaints struct {
	// Effect for taint. Accepted values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect *string `json:"effect" tf:"effect"`
	// Key for taint
	Key *string `json:"key" tf:"key"`
	// Value for taint.
	Value *string `json:"value" tf:"value"`
}

type ClusterSpecWebhook struct {
	Level *string `json:"level" tf:"level"`
	Type  *string `json:"type" tf:"type"`
	Url   *string `json:"url" tf:"url"`
}

type ClusterSpecWorkerPoolsZones struct {
	// +optional
	PrivateVLAN *string `json:"privateVLAN,omitempty" tf:"private_vlan"`
	// +optional
	PublicVLAN *string `json:"publicVLAN,omitempty" tf:"public_vlan"`
	// +optional
	WorkerCount *int64 `json:"workerCount,omitempty" tf:"worker_count"`
	// +optional
	Zone *string `json:"zone,omitempty" tf:"zone"`
}

type ClusterSpecWorkerPools struct {
	// +optional
	Hardware *string `json:"hardware,omitempty" tf:"hardware"`
	// +optional
	ID *string `json:"ID,omitempty" tf:"id"`
	// +optional
	Labels map[string]string `json:"labels,omitempty" tf:"labels"`
	// +optional
	MachineType *string `json:"machineType,omitempty" tf:"machine_type"`
	// +optional
	Name *string `json:"name,omitempty" tf:"name"`
	// +optional
	SizePerZone *int64 `json:"sizePerZone,omitempty" tf:"size_per_zone"`
	// +optional
	State *string `json:"state,omitempty" tf:"state"`
	// +optional
	Zones []ClusterSpecWorkerPoolsZones `json:"zones,omitempty" tf:"zones"`
}

type ClusterSpecWorkersInfo struct {
	// +optional
	ID *string `json:"ID,omitempty" tf:"id"`
	// +optional
	PoolName *string `json:"poolName,omitempty" tf:"pool_name"`
	// +optional
	Version *string `json:"version,omitempty" tf:"version"`
}

type ClusterSpec struct {
	State *ClusterSpecResource `json:"state,omitempty" tf:"-"`

	Resource ClusterSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	SecretRef *core.LocalObjectReference `json:"secretRef,omitempty" tf:"-"`
}

type ClusterSpecResource struct {
	Timeouts *base.ResourceTimeout `json:"timeouts,omitempty" tf:"timeouts"`

	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// The bluemix account guid this cluster belongs to
	// +optional
	// Deprecated
	AccountGuid *string `json:"accountGuid,omitempty" tf:"account_guid"`
	// +optional
	Albs []ClusterSpecAlbs `json:"albs,omitempty" tf:"albs"`
	// +optional
	// Deprecated
	Billing *string `json:"billing,omitempty" tf:"billing"`
	// CRN of resource instance
	// +optional
	Crn *string `json:"crn,omitempty" tf:"crn"`
	// The datacenter where this cluster will be deployed
	Datacenter *string `json:"datacenter" tf:"datacenter"`
	// The size of the default worker pool
	// +optional
	DefaultPoolSize *int64 `json:"defaultPoolSize,omitempty" tf:"default_pool_size"`
	// disc encryption done, if set to true.
	// +optional
	DiskEncryption *bool `json:"diskEncryption,omitempty" tf:"disk_encryption"`
	// Entitlement option reduces additional OCP Licence cost in Openshift Clusters
	// +optional
	Entitlement *string `json:"entitlement,omitempty" tf:"entitlement"`
	// Force the removal of a cluster and its persistent storage. Deleted data cannot be recovered
	// +optional
	ForceDeleteStorage *bool `json:"forceDeleteStorage,omitempty" tf:"force_delete_storage"`
	// Set true for gateway enabled clusters
	// +optional
	GatewayEnabled *bool `json:"gatewayEnabled,omitempty" tf:"gateway_enabled"`
	// Hardware type
	Hardware *string `json:"hardware" tf:"hardware"`
	// +optional
	IngressHostname *string `json:"ingressHostname,omitempty" tf:"ingress_hostname"`
	// +optional
	IngressSecret *string `json:"-" sensitive:"true" tf:"ingress_secret"`
	// +optional
	// Deprecated
	IsTrusted *bool `json:"isTrusted,omitempty" tf:"is_trusted"`
	// Enables KMS on a given cluster
	// +optional
	KmsConfig *ClusterSpecKmsConfig `json:"kmsConfig,omitempty" tf:"kms_config"`
	// Kubernetes version info
	// +optional
	KubeVersion *string `json:"kubeVersion,omitempty" tf:"kube_version"`
	// list of labels to the default worker pool
	// +optional
	Labels *map[string]string `json:"labels,omitempty" tf:"labels"`
	// Machine type
	// +optional
	MachineType *string `json:"machineType,omitempty" tf:"machine_type"`
	// The cluster name
	Name *string `json:"name" tf:"name"`
	// Boolean value set to true when subnet creation is not required.
	// +optional
	NoSubnet *bool `json:"noSubnet,omitempty" tf:"no_subnet"`
	// The bluemix organization guid this cluster belongs to
	// +optional
	// Deprecated
	OrgGuid *string `json:"orgGuid,omitempty" tf:"org_guid"`
	// Kubernetes patch version
	// +optional
	PatchVersion *string `json:"patchVersion,omitempty" tf:"patch_version"`
	// Custom subnet CIDR to provide private IP addresses for pods
	// +optional
	PodSubnet *string `json:"podSubnet,omitempty" tf:"pod_subnet"`
	// +optional
	PrivateServiceEndpoint *bool `json:"privateServiceEndpoint,omitempty" tf:"private_service_endpoint"`
	// +optional
	PrivateServiceEndpointURL *string `json:"privateServiceEndpointURL,omitempty" tf:"private_service_endpoint_url"`
	// Private VLAN ID
	// +optional
	PrivateVLANID *string `json:"privateVLANID,omitempty" tf:"private_vlan_id"`
	// +optional
	PublicServiceEndpoint *bool `json:"publicServiceEndpoint,omitempty" tf:"public_service_endpoint"`
	// +optional
	PublicServiceEndpointURL *string `json:"publicServiceEndpointURL,omitempty" tf:"public_service_endpoint_url"`
	// Public VLAN ID
	// +optional
	PublicVLANID *string `json:"publicVLANID,omitempty" tf:"public_vlan_id"`
	// The cluster region
	// +optional
	// Deprecated
	Region *string `json:"region,omitempty" tf:"region"`
	// The URL of the IBM Cloud dashboard that can be used to explore and view details about this cluster
	// +optional
	ResourceControllerURL *string `json:"resourceControllerURL,omitempty" tf:"resource_controller_url"`
	// The crn of the resource
	// +optional
	ResourceCrn *string `json:"resourceCrn,omitempty" tf:"resource_crn"`
	// ID of the resource group.
	// +optional
	ResourceGroupID *string `json:"resourceGroupID,omitempty" tf:"resource_group_id"`
	// The resource group name in which resource is provisioned
	// +optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name"`
	// The name of the resource
	// +optional
	ResourceName *string `json:"resourceName,omitempty" tf:"resource_name"`
	// The status of the resource
	// +optional
	ResourceStatus *string `json:"resourceStatus,omitempty" tf:"resource_status"`
	// Argument which helps to retry the patch version updates on worker nodes. Increment the value to retry the patch updates if the previous apply fails
	// +optional
	RetryPatchVersion *int64 `json:"retryPatchVersion,omitempty" tf:"retry_patch_version"`
	// +optional
	ServerURL *string `json:"serverURL,omitempty" tf:"server_url"`
	// Custom subnet CIDR to provide private IP addresses for services
	// +optional
	ServiceSubnet *string `json:"serviceSubnet,omitempty" tf:"service_subnet"`
	// The bluemix space guid this cluster belongs to
	// +optional
	// Deprecated
	SpaceGuid *string `json:"spaceGuid,omitempty" tf:"space_guid"`
	// List of subnet IDs
	// +optional
	SubnetID []string `json:"subnetID,omitempty" tf:"subnet_id"`
	// Tags for the resource
	// +optional
	Tags []string `json:"tags,omitempty" tf:"tags"`
	// WorkerPool Taints
	// +optional
	Taints []ClusterSpecTaints `json:"taints,omitempty" tf:"taints"`
	// Updates all the woker nodes if sets to true
	// +optional
	UpdateAllWorkers *bool `json:"updateAllWorkers,omitempty" tf:"update_all_workers"`
	// Wait for worker node to update during kube version update.
	// +optional
	WaitForWorkerUpdate *bool `json:"waitForWorkerUpdate,omitempty" tf:"wait_for_worker_update"`
	// wait_till can be configured for Master Ready, One worker Ready or Ingress Ready
	// +optional
	WaitTill *string `json:"waitTill,omitempty" tf:"wait_till"`
	// +optional
	// Deprecated
	WaitTimeMinutes *int64 `json:"waitTimeMinutes,omitempty" tf:"wait_time_minutes"`
	// +optional
	Webhook []ClusterSpecWebhook `json:"webhook,omitempty" tf:"webhook"`
	// Number of worker nodes
	// +optional
	// Deprecated
	WorkerNum *int64 `json:"workerNum,omitempty" tf:"worker_num"`
	// +optional
	WorkerPools []ClusterSpecWorkerPools `json:"workerPools,omitempty" tf:"worker_pools"`
	// The IDs of the worker node
	// +optional
	WorkersInfo []ClusterSpecWorkersInfo `json:"workersInfo,omitempty" tf:"workers_info"`
}

type ClusterStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ClusterList is a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Cluster CRD objects
	Items []Cluster `json:"items,omitempty"`
}
