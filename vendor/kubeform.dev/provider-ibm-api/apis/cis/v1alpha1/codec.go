/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecMinify{}).Type1()):            DomainSettingsSpecMinifyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecMobileRedirect{}).Type1()):    DomainSettingsSpecMobileRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecSecurityHeader{}).Type1()):    DomainSettingsSpecSecurityHeaderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecAccessRule{}).Type1()):              FirewallSpecAccessRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecAccessRuleConfiguration{}).Type1()): FirewallSpecAccessRuleConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLockdown{}).Type1()):                FirewallSpecLockdownCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecUaRule{}).Type1()):                  FirewallSpecUaRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecUaRuleConfiguration{}).Type1()):     FirewallSpecUaRuleConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PageRuleSpecTargetsConstraint{}).Type1()):       PageRuleSpecTargetsConstraintCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecAction{}).Type1()):                 RateLimitSpecActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecActionResponse{}).Type1()):         RateLimitSpecActionResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecCorrelate{}).Type1()):              RateLimitSpecCorrelateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatch{}).Type1()):                  RateLimitSpecMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatchRequest{}).Type1()):           RateLimitSpecMatchRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatchResponse{}).Type1()):          RateLimitSpecMatchResponseCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecMinify{}).Type1()):            DomainSettingsSpecMinifyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecMobileRedirect{}).Type1()):    DomainSettingsSpecMobileRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecSecurityHeader{}).Type1()):    DomainSettingsSpecSecurityHeaderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecAccessRule{}).Type1()):              FirewallSpecAccessRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecAccessRuleConfiguration{}).Type1()): FirewallSpecAccessRuleConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLockdown{}).Type1()):                FirewallSpecLockdownCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecUaRule{}).Type1()):                  FirewallSpecUaRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecUaRuleConfiguration{}).Type1()):     FirewallSpecUaRuleConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PageRuleSpecTargetsConstraint{}).Type1()):       PageRuleSpecTargetsConstraintCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecAction{}).Type1()):                 RateLimitSpecActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecActionResponse{}).Type1()):         RateLimitSpecActionResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecCorrelate{}).Type1()):              RateLimitSpecCorrelateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatch{}).Type1()):                  RateLimitSpecMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatchRequest{}).Type1()):           RateLimitSpecMatchRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatchResponse{}).Type1()):          RateLimitSpecMatchResponseCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type DomainSettingsSpecMinifyCodec struct {
}

func (DomainSettingsSpecMinifyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DomainSettingsSpecMinify)(ptr) == nil
}

func (DomainSettingsSpecMinifyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DomainSettingsSpecMinify)(ptr)
	var objs []DomainSettingsSpecMinify
	if obj != nil {
		objs = []DomainSettingsSpecMinify{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecMinify{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DomainSettingsSpecMinifyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DomainSettingsSpecMinify)(ptr) = DomainSettingsSpecMinify{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DomainSettingsSpecMinify

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecMinify{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DomainSettingsSpecMinify)(ptr) = objs[0]
			} else {
				*(*DomainSettingsSpecMinify)(ptr) = DomainSettingsSpecMinify{}
			}
		} else {
			*(*DomainSettingsSpecMinify)(ptr) = DomainSettingsSpecMinify{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DomainSettingsSpecMinify

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecMinify{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DomainSettingsSpecMinify)(ptr) = obj
		} else {
			*(*DomainSettingsSpecMinify)(ptr) = DomainSettingsSpecMinify{}
		}
	default:
		iter.ReportError("decode DomainSettingsSpecMinify", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DomainSettingsSpecMobileRedirectCodec struct {
}

func (DomainSettingsSpecMobileRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DomainSettingsSpecMobileRedirect)(ptr) == nil
}

func (DomainSettingsSpecMobileRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DomainSettingsSpecMobileRedirect)(ptr)
	var objs []DomainSettingsSpecMobileRedirect
	if obj != nil {
		objs = []DomainSettingsSpecMobileRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecMobileRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DomainSettingsSpecMobileRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DomainSettingsSpecMobileRedirect)(ptr) = DomainSettingsSpecMobileRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DomainSettingsSpecMobileRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecMobileRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DomainSettingsSpecMobileRedirect)(ptr) = objs[0]
			} else {
				*(*DomainSettingsSpecMobileRedirect)(ptr) = DomainSettingsSpecMobileRedirect{}
			}
		} else {
			*(*DomainSettingsSpecMobileRedirect)(ptr) = DomainSettingsSpecMobileRedirect{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DomainSettingsSpecMobileRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecMobileRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DomainSettingsSpecMobileRedirect)(ptr) = obj
		} else {
			*(*DomainSettingsSpecMobileRedirect)(ptr) = DomainSettingsSpecMobileRedirect{}
		}
	default:
		iter.ReportError("decode DomainSettingsSpecMobileRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DomainSettingsSpecSecurityHeaderCodec struct {
}

func (DomainSettingsSpecSecurityHeaderCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DomainSettingsSpecSecurityHeader)(ptr) == nil
}

func (DomainSettingsSpecSecurityHeaderCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DomainSettingsSpecSecurityHeader)(ptr)
	var objs []DomainSettingsSpecSecurityHeader
	if obj != nil {
		objs = []DomainSettingsSpecSecurityHeader{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecSecurityHeader{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DomainSettingsSpecSecurityHeaderCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DomainSettingsSpecSecurityHeader)(ptr) = DomainSettingsSpecSecurityHeader{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DomainSettingsSpecSecurityHeader

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecSecurityHeader{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DomainSettingsSpecSecurityHeader)(ptr) = objs[0]
			} else {
				*(*DomainSettingsSpecSecurityHeader)(ptr) = DomainSettingsSpecSecurityHeader{}
			}
		} else {
			*(*DomainSettingsSpecSecurityHeader)(ptr) = DomainSettingsSpecSecurityHeader{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DomainSettingsSpecSecurityHeader

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSettingsSpecSecurityHeader{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DomainSettingsSpecSecurityHeader)(ptr) = obj
		} else {
			*(*DomainSettingsSpecSecurityHeader)(ptr) = DomainSettingsSpecSecurityHeader{}
		}
	default:
		iter.ReportError("decode DomainSettingsSpecSecurityHeader", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirewallSpecAccessRuleCodec struct {
}

func (FirewallSpecAccessRuleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirewallSpecAccessRule)(ptr) == nil
}

func (FirewallSpecAccessRuleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirewallSpecAccessRule)(ptr)
	var objs []FirewallSpecAccessRule
	if obj != nil {
		objs = []FirewallSpecAccessRule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecAccessRule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirewallSpecAccessRuleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirewallSpecAccessRule)(ptr) = FirewallSpecAccessRule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirewallSpecAccessRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecAccessRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirewallSpecAccessRule)(ptr) = objs[0]
			} else {
				*(*FirewallSpecAccessRule)(ptr) = FirewallSpecAccessRule{}
			}
		} else {
			*(*FirewallSpecAccessRule)(ptr) = FirewallSpecAccessRule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FirewallSpecAccessRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecAccessRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FirewallSpecAccessRule)(ptr) = obj
		} else {
			*(*FirewallSpecAccessRule)(ptr) = FirewallSpecAccessRule{}
		}
	default:
		iter.ReportError("decode FirewallSpecAccessRule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirewallSpecAccessRuleConfigurationCodec struct {
}

func (FirewallSpecAccessRuleConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirewallSpecAccessRuleConfiguration)(ptr) == nil
}

func (FirewallSpecAccessRuleConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirewallSpecAccessRuleConfiguration)(ptr)
	var objs []FirewallSpecAccessRuleConfiguration
	if obj != nil {
		objs = []FirewallSpecAccessRuleConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecAccessRuleConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirewallSpecAccessRuleConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirewallSpecAccessRuleConfiguration)(ptr) = FirewallSpecAccessRuleConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirewallSpecAccessRuleConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecAccessRuleConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirewallSpecAccessRuleConfiguration)(ptr) = objs[0]
			} else {
				*(*FirewallSpecAccessRuleConfiguration)(ptr) = FirewallSpecAccessRuleConfiguration{}
			}
		} else {
			*(*FirewallSpecAccessRuleConfiguration)(ptr) = FirewallSpecAccessRuleConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FirewallSpecAccessRuleConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecAccessRuleConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FirewallSpecAccessRuleConfiguration)(ptr) = obj
		} else {
			*(*FirewallSpecAccessRuleConfiguration)(ptr) = FirewallSpecAccessRuleConfiguration{}
		}
	default:
		iter.ReportError("decode FirewallSpecAccessRuleConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirewallSpecLockdownCodec struct {
}

func (FirewallSpecLockdownCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirewallSpecLockdown)(ptr) == nil
}

func (FirewallSpecLockdownCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirewallSpecLockdown)(ptr)
	var objs []FirewallSpecLockdown
	if obj != nil {
		objs = []FirewallSpecLockdown{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLockdown{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirewallSpecLockdownCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirewallSpecLockdown)(ptr) = FirewallSpecLockdown{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirewallSpecLockdown

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLockdown{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirewallSpecLockdown)(ptr) = objs[0]
			} else {
				*(*FirewallSpecLockdown)(ptr) = FirewallSpecLockdown{}
			}
		} else {
			*(*FirewallSpecLockdown)(ptr) = FirewallSpecLockdown{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FirewallSpecLockdown

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLockdown{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FirewallSpecLockdown)(ptr) = obj
		} else {
			*(*FirewallSpecLockdown)(ptr) = FirewallSpecLockdown{}
		}
	default:
		iter.ReportError("decode FirewallSpecLockdown", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirewallSpecUaRuleCodec struct {
}

func (FirewallSpecUaRuleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirewallSpecUaRule)(ptr) == nil
}

func (FirewallSpecUaRuleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirewallSpecUaRule)(ptr)
	var objs []FirewallSpecUaRule
	if obj != nil {
		objs = []FirewallSpecUaRule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecUaRule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirewallSpecUaRuleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirewallSpecUaRule)(ptr) = FirewallSpecUaRule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirewallSpecUaRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecUaRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirewallSpecUaRule)(ptr) = objs[0]
			} else {
				*(*FirewallSpecUaRule)(ptr) = FirewallSpecUaRule{}
			}
		} else {
			*(*FirewallSpecUaRule)(ptr) = FirewallSpecUaRule{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FirewallSpecUaRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecUaRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FirewallSpecUaRule)(ptr) = obj
		} else {
			*(*FirewallSpecUaRule)(ptr) = FirewallSpecUaRule{}
		}
	default:
		iter.ReportError("decode FirewallSpecUaRule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirewallSpecUaRuleConfigurationCodec struct {
}

func (FirewallSpecUaRuleConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirewallSpecUaRuleConfiguration)(ptr) == nil
}

func (FirewallSpecUaRuleConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirewallSpecUaRuleConfiguration)(ptr)
	var objs []FirewallSpecUaRuleConfiguration
	if obj != nil {
		objs = []FirewallSpecUaRuleConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecUaRuleConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirewallSpecUaRuleConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirewallSpecUaRuleConfiguration)(ptr) = FirewallSpecUaRuleConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirewallSpecUaRuleConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecUaRuleConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirewallSpecUaRuleConfiguration)(ptr) = objs[0]
			} else {
				*(*FirewallSpecUaRuleConfiguration)(ptr) = FirewallSpecUaRuleConfiguration{}
			}
		} else {
			*(*FirewallSpecUaRuleConfiguration)(ptr) = FirewallSpecUaRuleConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj FirewallSpecUaRuleConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecUaRuleConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*FirewallSpecUaRuleConfiguration)(ptr) = obj
		} else {
			*(*FirewallSpecUaRuleConfiguration)(ptr) = FirewallSpecUaRuleConfiguration{}
		}
	default:
		iter.ReportError("decode FirewallSpecUaRuleConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PageRuleSpecTargetsConstraintCodec struct {
}

func (PageRuleSpecTargetsConstraintCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PageRuleSpecTargetsConstraint)(ptr) == nil
}

func (PageRuleSpecTargetsConstraintCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PageRuleSpecTargetsConstraint)(ptr)
	var objs []PageRuleSpecTargetsConstraint
	if obj != nil {
		objs = []PageRuleSpecTargetsConstraint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PageRuleSpecTargetsConstraint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PageRuleSpecTargetsConstraintCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PageRuleSpecTargetsConstraint)(ptr) = PageRuleSpecTargetsConstraint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PageRuleSpecTargetsConstraint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PageRuleSpecTargetsConstraint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PageRuleSpecTargetsConstraint)(ptr) = objs[0]
			} else {
				*(*PageRuleSpecTargetsConstraint)(ptr) = PageRuleSpecTargetsConstraint{}
			}
		} else {
			*(*PageRuleSpecTargetsConstraint)(ptr) = PageRuleSpecTargetsConstraint{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj PageRuleSpecTargetsConstraint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PageRuleSpecTargetsConstraint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*PageRuleSpecTargetsConstraint)(ptr) = obj
		} else {
			*(*PageRuleSpecTargetsConstraint)(ptr) = PageRuleSpecTargetsConstraint{}
		}
	default:
		iter.ReportError("decode PageRuleSpecTargetsConstraint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RateLimitSpecActionCodec struct {
}

func (RateLimitSpecActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RateLimitSpecAction)(ptr) == nil
}

func (RateLimitSpecActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RateLimitSpecAction)(ptr)
	var objs []RateLimitSpecAction
	if obj != nil {
		objs = []RateLimitSpecAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RateLimitSpecActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RateLimitSpecAction)(ptr) = RateLimitSpecAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RateLimitSpecAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RateLimitSpecAction)(ptr) = objs[0]
			} else {
				*(*RateLimitSpecAction)(ptr) = RateLimitSpecAction{}
			}
		} else {
			*(*RateLimitSpecAction)(ptr) = RateLimitSpecAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RateLimitSpecAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RateLimitSpecAction)(ptr) = obj
		} else {
			*(*RateLimitSpecAction)(ptr) = RateLimitSpecAction{}
		}
	default:
		iter.ReportError("decode RateLimitSpecAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RateLimitSpecActionResponseCodec struct {
}

func (RateLimitSpecActionResponseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RateLimitSpecActionResponse)(ptr) == nil
}

func (RateLimitSpecActionResponseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RateLimitSpecActionResponse)(ptr)
	var objs []RateLimitSpecActionResponse
	if obj != nil {
		objs = []RateLimitSpecActionResponse{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecActionResponse{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RateLimitSpecActionResponseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RateLimitSpecActionResponse)(ptr) = RateLimitSpecActionResponse{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RateLimitSpecActionResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecActionResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RateLimitSpecActionResponse)(ptr) = objs[0]
			} else {
				*(*RateLimitSpecActionResponse)(ptr) = RateLimitSpecActionResponse{}
			}
		} else {
			*(*RateLimitSpecActionResponse)(ptr) = RateLimitSpecActionResponse{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RateLimitSpecActionResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecActionResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RateLimitSpecActionResponse)(ptr) = obj
		} else {
			*(*RateLimitSpecActionResponse)(ptr) = RateLimitSpecActionResponse{}
		}
	default:
		iter.ReportError("decode RateLimitSpecActionResponse", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RateLimitSpecCorrelateCodec struct {
}

func (RateLimitSpecCorrelateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RateLimitSpecCorrelate)(ptr) == nil
}

func (RateLimitSpecCorrelateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RateLimitSpecCorrelate)(ptr)
	var objs []RateLimitSpecCorrelate
	if obj != nil {
		objs = []RateLimitSpecCorrelate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecCorrelate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RateLimitSpecCorrelateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RateLimitSpecCorrelate)(ptr) = RateLimitSpecCorrelate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RateLimitSpecCorrelate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecCorrelate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RateLimitSpecCorrelate)(ptr) = objs[0]
			} else {
				*(*RateLimitSpecCorrelate)(ptr) = RateLimitSpecCorrelate{}
			}
		} else {
			*(*RateLimitSpecCorrelate)(ptr) = RateLimitSpecCorrelate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RateLimitSpecCorrelate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecCorrelate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RateLimitSpecCorrelate)(ptr) = obj
		} else {
			*(*RateLimitSpecCorrelate)(ptr) = RateLimitSpecCorrelate{}
		}
	default:
		iter.ReportError("decode RateLimitSpecCorrelate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RateLimitSpecMatchCodec struct {
}

func (RateLimitSpecMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RateLimitSpecMatch)(ptr) == nil
}

func (RateLimitSpecMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RateLimitSpecMatch)(ptr)
	var objs []RateLimitSpecMatch
	if obj != nil {
		objs = []RateLimitSpecMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RateLimitSpecMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RateLimitSpecMatch)(ptr) = RateLimitSpecMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RateLimitSpecMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RateLimitSpecMatch)(ptr) = objs[0]
			} else {
				*(*RateLimitSpecMatch)(ptr) = RateLimitSpecMatch{}
			}
		} else {
			*(*RateLimitSpecMatch)(ptr) = RateLimitSpecMatch{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RateLimitSpecMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RateLimitSpecMatch)(ptr) = obj
		} else {
			*(*RateLimitSpecMatch)(ptr) = RateLimitSpecMatch{}
		}
	default:
		iter.ReportError("decode RateLimitSpecMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RateLimitSpecMatchRequestCodec struct {
}

func (RateLimitSpecMatchRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RateLimitSpecMatchRequest)(ptr) == nil
}

func (RateLimitSpecMatchRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RateLimitSpecMatchRequest)(ptr)
	var objs []RateLimitSpecMatchRequest
	if obj != nil {
		objs = []RateLimitSpecMatchRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatchRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RateLimitSpecMatchRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RateLimitSpecMatchRequest)(ptr) = RateLimitSpecMatchRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RateLimitSpecMatchRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatchRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RateLimitSpecMatchRequest)(ptr) = objs[0]
			} else {
				*(*RateLimitSpecMatchRequest)(ptr) = RateLimitSpecMatchRequest{}
			}
		} else {
			*(*RateLimitSpecMatchRequest)(ptr) = RateLimitSpecMatchRequest{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RateLimitSpecMatchRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatchRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RateLimitSpecMatchRequest)(ptr) = obj
		} else {
			*(*RateLimitSpecMatchRequest)(ptr) = RateLimitSpecMatchRequest{}
		}
	default:
		iter.ReportError("decode RateLimitSpecMatchRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RateLimitSpecMatchResponseCodec struct {
}

func (RateLimitSpecMatchResponseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RateLimitSpecMatchResponse)(ptr) == nil
}

func (RateLimitSpecMatchResponseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RateLimitSpecMatchResponse)(ptr)
	var objs []RateLimitSpecMatchResponse
	if obj != nil {
		objs = []RateLimitSpecMatchResponse{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatchResponse{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RateLimitSpecMatchResponseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RateLimitSpecMatchResponse)(ptr) = RateLimitSpecMatchResponse{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RateLimitSpecMatchResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatchResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RateLimitSpecMatchResponse)(ptr) = objs[0]
			} else {
				*(*RateLimitSpecMatchResponse)(ptr) = RateLimitSpecMatchResponse{}
			}
		} else {
			*(*RateLimitSpecMatchResponse)(ptr) = RateLimitSpecMatchResponse{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RateLimitSpecMatchResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RateLimitSpecMatchResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RateLimitSpecMatchResponse)(ptr) = obj
		} else {
			*(*RateLimitSpecMatchResponse)(ptr) = RateLimitSpecMatchResponse{}
		}
	default:
		iter.ReportError("decode RateLimitSpecMatchResponse", "unexpected JSON type")
	}
}
