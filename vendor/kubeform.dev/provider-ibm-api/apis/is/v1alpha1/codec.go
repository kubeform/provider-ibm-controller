/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootVolume{}).Type1()):                               InstanceSpecBootVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPrimaryNetworkInterface{}).Type1()):                  InstanceSpecPrimaryNetworkInterfaceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecBootVolume{}).Type1()):                       InstanceTemplateSpecBootVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecPrimaryNetworkInterface{}).Type1()):          InstanceTemplateSpecPrimaryNetworkInterfaceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecVolumeAttachmentsVolumePrototype{}).Type1()): InstanceTemplateSpecVolumeAttachmentsVolumePrototypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesIcmp{}).Type1()):                              NetworkACLSpecRulesIcmpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesTcp{}).Type1()):                               NetworkACLSpecRulesTcpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesUdp{}).Type1()):                               NetworkACLSpecRulesUdpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecIcmp{}).Type1()):                               NetworkACLRuleSpecIcmpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecTcp{}).Type1()):                                NetworkACLRuleSpecTcpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecUdp{}).Type1()):                                NetworkACLRuleSpecUdpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecIcmp{}).Type1()):                            SecurityGroupRuleSpecIcmpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecTcp{}).Type1()):                             SecurityGroupRuleSpecTcpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecUdp{}).Type1()):                             SecurityGroupRuleSpecUdpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualEndpointGatewaySpecTarget{}).Type1()):                     VirtualEndpointGatewaySpecTargetCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootVolume{}).Type1()):                               InstanceSpecBootVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPrimaryNetworkInterface{}).Type1()):                  InstanceSpecPrimaryNetworkInterfaceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecBootVolume{}).Type1()):                       InstanceTemplateSpecBootVolumeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecPrimaryNetworkInterface{}).Type1()):          InstanceTemplateSpecPrimaryNetworkInterfaceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecVolumeAttachmentsVolumePrototype{}).Type1()): InstanceTemplateSpecVolumeAttachmentsVolumePrototypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesIcmp{}).Type1()):                              NetworkACLSpecRulesIcmpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesTcp{}).Type1()):                               NetworkACLSpecRulesTcpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesUdp{}).Type1()):                               NetworkACLSpecRulesUdpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecIcmp{}).Type1()):                               NetworkACLRuleSpecIcmpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecTcp{}).Type1()):                                NetworkACLRuleSpecTcpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecUdp{}).Type1()):                                NetworkACLRuleSpecUdpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecIcmp{}).Type1()):                            SecurityGroupRuleSpecIcmpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecTcp{}).Type1()):                             SecurityGroupRuleSpecTcpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecUdp{}).Type1()):                             SecurityGroupRuleSpecUdpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualEndpointGatewaySpecTarget{}).Type1()):                     VirtualEndpointGatewaySpecTargetCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type InstanceSpecBootVolumeCodec struct {
}

func (InstanceSpecBootVolumeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecBootVolume)(ptr) == nil
}

func (InstanceSpecBootVolumeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecBootVolume)(ptr)
	var objs []InstanceSpecBootVolume
	if obj != nil {
		objs = []InstanceSpecBootVolume{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootVolume{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecBootVolumeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecBootVolume)(ptr) = InstanceSpecBootVolume{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecBootVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecBootVolume)(ptr) = objs[0]
			} else {
				*(*InstanceSpecBootVolume)(ptr) = InstanceSpecBootVolume{}
			}
		} else {
			*(*InstanceSpecBootVolume)(ptr) = InstanceSpecBootVolume{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecBootVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecBootVolume)(ptr) = obj
		} else {
			*(*InstanceSpecBootVolume)(ptr) = InstanceSpecBootVolume{}
		}
	default:
		iter.ReportError("decode InstanceSpecBootVolume", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecPrimaryNetworkInterfaceCodec struct {
}

func (InstanceSpecPrimaryNetworkInterfaceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecPrimaryNetworkInterface)(ptr) == nil
}

func (InstanceSpecPrimaryNetworkInterfaceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecPrimaryNetworkInterface)(ptr)
	var objs []InstanceSpecPrimaryNetworkInterface
	if obj != nil {
		objs = []InstanceSpecPrimaryNetworkInterface{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPrimaryNetworkInterface{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecPrimaryNetworkInterfaceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecPrimaryNetworkInterface)(ptr) = InstanceSpecPrimaryNetworkInterface{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecPrimaryNetworkInterface

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPrimaryNetworkInterface{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecPrimaryNetworkInterface)(ptr) = objs[0]
			} else {
				*(*InstanceSpecPrimaryNetworkInterface)(ptr) = InstanceSpecPrimaryNetworkInterface{}
			}
		} else {
			*(*InstanceSpecPrimaryNetworkInterface)(ptr) = InstanceSpecPrimaryNetworkInterface{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecPrimaryNetworkInterface

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecPrimaryNetworkInterface{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecPrimaryNetworkInterface)(ptr) = obj
		} else {
			*(*InstanceSpecPrimaryNetworkInterface)(ptr) = InstanceSpecPrimaryNetworkInterface{}
		}
	default:
		iter.ReportError("decode InstanceSpecPrimaryNetworkInterface", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecBootVolumeCodec struct {
}

func (InstanceTemplateSpecBootVolumeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecBootVolume)(ptr) == nil
}

func (InstanceTemplateSpecBootVolumeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecBootVolume)(ptr)
	var objs []InstanceTemplateSpecBootVolume
	if obj != nil {
		objs = []InstanceTemplateSpecBootVolume{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecBootVolume{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecBootVolumeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecBootVolume)(ptr) = InstanceTemplateSpecBootVolume{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecBootVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecBootVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecBootVolume)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecBootVolume)(ptr) = InstanceTemplateSpecBootVolume{}
			}
		} else {
			*(*InstanceTemplateSpecBootVolume)(ptr) = InstanceTemplateSpecBootVolume{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceTemplateSpecBootVolume

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecBootVolume{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceTemplateSpecBootVolume)(ptr) = obj
		} else {
			*(*InstanceTemplateSpecBootVolume)(ptr) = InstanceTemplateSpecBootVolume{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecBootVolume", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecPrimaryNetworkInterfaceCodec struct {
}

func (InstanceTemplateSpecPrimaryNetworkInterfaceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecPrimaryNetworkInterface)(ptr) == nil
}

func (InstanceTemplateSpecPrimaryNetworkInterfaceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecPrimaryNetworkInterface)(ptr)
	var objs []InstanceTemplateSpecPrimaryNetworkInterface
	if obj != nil {
		objs = []InstanceTemplateSpecPrimaryNetworkInterface{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecPrimaryNetworkInterface{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecPrimaryNetworkInterfaceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecPrimaryNetworkInterface)(ptr) = InstanceTemplateSpecPrimaryNetworkInterface{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecPrimaryNetworkInterface

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecPrimaryNetworkInterface{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecPrimaryNetworkInterface)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecPrimaryNetworkInterface)(ptr) = InstanceTemplateSpecPrimaryNetworkInterface{}
			}
		} else {
			*(*InstanceTemplateSpecPrimaryNetworkInterface)(ptr) = InstanceTemplateSpecPrimaryNetworkInterface{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceTemplateSpecPrimaryNetworkInterface

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecPrimaryNetworkInterface{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceTemplateSpecPrimaryNetworkInterface)(ptr) = obj
		} else {
			*(*InstanceTemplateSpecPrimaryNetworkInterface)(ptr) = InstanceTemplateSpecPrimaryNetworkInterface{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecPrimaryNetworkInterface", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecVolumeAttachmentsVolumePrototypeCodec struct {
}

func (InstanceTemplateSpecVolumeAttachmentsVolumePrototypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecVolumeAttachmentsVolumePrototype)(ptr) == nil
}

func (InstanceTemplateSpecVolumeAttachmentsVolumePrototypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecVolumeAttachmentsVolumePrototype)(ptr)
	var objs []InstanceTemplateSpecVolumeAttachmentsVolumePrototype
	if obj != nil {
		objs = []InstanceTemplateSpecVolumeAttachmentsVolumePrototype{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecVolumeAttachmentsVolumePrototype{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecVolumeAttachmentsVolumePrototypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecVolumeAttachmentsVolumePrototype)(ptr) = InstanceTemplateSpecVolumeAttachmentsVolumePrototype{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecVolumeAttachmentsVolumePrototype

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecVolumeAttachmentsVolumePrototype{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecVolumeAttachmentsVolumePrototype)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecVolumeAttachmentsVolumePrototype)(ptr) = InstanceTemplateSpecVolumeAttachmentsVolumePrototype{}
			}
		} else {
			*(*InstanceTemplateSpecVolumeAttachmentsVolumePrototype)(ptr) = InstanceTemplateSpecVolumeAttachmentsVolumePrototype{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceTemplateSpecVolumeAttachmentsVolumePrototype

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecVolumeAttachmentsVolumePrototype{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceTemplateSpecVolumeAttachmentsVolumePrototype)(ptr) = obj
		} else {
			*(*InstanceTemplateSpecVolumeAttachmentsVolumePrototype)(ptr) = InstanceTemplateSpecVolumeAttachmentsVolumePrototype{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecVolumeAttachmentsVolumePrototype", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkACLSpecRulesIcmpCodec struct {
}

func (NetworkACLSpecRulesIcmpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkACLSpecRulesIcmp)(ptr) == nil
}

func (NetworkACLSpecRulesIcmpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkACLSpecRulesIcmp)(ptr)
	var objs []NetworkACLSpecRulesIcmp
	if obj != nil {
		objs = []NetworkACLSpecRulesIcmp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesIcmp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkACLSpecRulesIcmpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkACLSpecRulesIcmp)(ptr) = NetworkACLSpecRulesIcmp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkACLSpecRulesIcmp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesIcmp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkACLSpecRulesIcmp)(ptr) = objs[0]
			} else {
				*(*NetworkACLSpecRulesIcmp)(ptr) = NetworkACLSpecRulesIcmp{}
			}
		} else {
			*(*NetworkACLSpecRulesIcmp)(ptr) = NetworkACLSpecRulesIcmp{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkACLSpecRulesIcmp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesIcmp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkACLSpecRulesIcmp)(ptr) = obj
		} else {
			*(*NetworkACLSpecRulesIcmp)(ptr) = NetworkACLSpecRulesIcmp{}
		}
	default:
		iter.ReportError("decode NetworkACLSpecRulesIcmp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkACLSpecRulesTcpCodec struct {
}

func (NetworkACLSpecRulesTcpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkACLSpecRulesTcp)(ptr) == nil
}

func (NetworkACLSpecRulesTcpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkACLSpecRulesTcp)(ptr)
	var objs []NetworkACLSpecRulesTcp
	if obj != nil {
		objs = []NetworkACLSpecRulesTcp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesTcp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkACLSpecRulesTcpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkACLSpecRulesTcp)(ptr) = NetworkACLSpecRulesTcp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkACLSpecRulesTcp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesTcp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkACLSpecRulesTcp)(ptr) = objs[0]
			} else {
				*(*NetworkACLSpecRulesTcp)(ptr) = NetworkACLSpecRulesTcp{}
			}
		} else {
			*(*NetworkACLSpecRulesTcp)(ptr) = NetworkACLSpecRulesTcp{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkACLSpecRulesTcp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesTcp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkACLSpecRulesTcp)(ptr) = obj
		} else {
			*(*NetworkACLSpecRulesTcp)(ptr) = NetworkACLSpecRulesTcp{}
		}
	default:
		iter.ReportError("decode NetworkACLSpecRulesTcp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkACLSpecRulesUdpCodec struct {
}

func (NetworkACLSpecRulesUdpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkACLSpecRulesUdp)(ptr) == nil
}

func (NetworkACLSpecRulesUdpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkACLSpecRulesUdp)(ptr)
	var objs []NetworkACLSpecRulesUdp
	if obj != nil {
		objs = []NetworkACLSpecRulesUdp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesUdp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkACLSpecRulesUdpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkACLSpecRulesUdp)(ptr) = NetworkACLSpecRulesUdp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkACLSpecRulesUdp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesUdp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkACLSpecRulesUdp)(ptr) = objs[0]
			} else {
				*(*NetworkACLSpecRulesUdp)(ptr) = NetworkACLSpecRulesUdp{}
			}
		} else {
			*(*NetworkACLSpecRulesUdp)(ptr) = NetworkACLSpecRulesUdp{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkACLSpecRulesUdp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLSpecRulesUdp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkACLSpecRulesUdp)(ptr) = obj
		} else {
			*(*NetworkACLSpecRulesUdp)(ptr) = NetworkACLSpecRulesUdp{}
		}
	default:
		iter.ReportError("decode NetworkACLSpecRulesUdp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkACLRuleSpecIcmpCodec struct {
}

func (NetworkACLRuleSpecIcmpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkACLRuleSpecIcmp)(ptr) == nil
}

func (NetworkACLRuleSpecIcmpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkACLRuleSpecIcmp)(ptr)
	var objs []NetworkACLRuleSpecIcmp
	if obj != nil {
		objs = []NetworkACLRuleSpecIcmp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecIcmp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkACLRuleSpecIcmpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkACLRuleSpecIcmp)(ptr) = NetworkACLRuleSpecIcmp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkACLRuleSpecIcmp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecIcmp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkACLRuleSpecIcmp)(ptr) = objs[0]
			} else {
				*(*NetworkACLRuleSpecIcmp)(ptr) = NetworkACLRuleSpecIcmp{}
			}
		} else {
			*(*NetworkACLRuleSpecIcmp)(ptr) = NetworkACLRuleSpecIcmp{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkACLRuleSpecIcmp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecIcmp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkACLRuleSpecIcmp)(ptr) = obj
		} else {
			*(*NetworkACLRuleSpecIcmp)(ptr) = NetworkACLRuleSpecIcmp{}
		}
	default:
		iter.ReportError("decode NetworkACLRuleSpecIcmp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkACLRuleSpecTcpCodec struct {
}

func (NetworkACLRuleSpecTcpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkACLRuleSpecTcp)(ptr) == nil
}

func (NetworkACLRuleSpecTcpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkACLRuleSpecTcp)(ptr)
	var objs []NetworkACLRuleSpecTcp
	if obj != nil {
		objs = []NetworkACLRuleSpecTcp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecTcp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkACLRuleSpecTcpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkACLRuleSpecTcp)(ptr) = NetworkACLRuleSpecTcp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkACLRuleSpecTcp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecTcp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkACLRuleSpecTcp)(ptr) = objs[0]
			} else {
				*(*NetworkACLRuleSpecTcp)(ptr) = NetworkACLRuleSpecTcp{}
			}
		} else {
			*(*NetworkACLRuleSpecTcp)(ptr) = NetworkACLRuleSpecTcp{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkACLRuleSpecTcp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecTcp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkACLRuleSpecTcp)(ptr) = obj
		} else {
			*(*NetworkACLRuleSpecTcp)(ptr) = NetworkACLRuleSpecTcp{}
		}
	default:
		iter.ReportError("decode NetworkACLRuleSpecTcp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkACLRuleSpecUdpCodec struct {
}

func (NetworkACLRuleSpecUdpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkACLRuleSpecUdp)(ptr) == nil
}

func (NetworkACLRuleSpecUdpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkACLRuleSpecUdp)(ptr)
	var objs []NetworkACLRuleSpecUdp
	if obj != nil {
		objs = []NetworkACLRuleSpecUdp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecUdp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkACLRuleSpecUdpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkACLRuleSpecUdp)(ptr) = NetworkACLRuleSpecUdp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkACLRuleSpecUdp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecUdp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkACLRuleSpecUdp)(ptr) = objs[0]
			} else {
				*(*NetworkACLRuleSpecUdp)(ptr) = NetworkACLRuleSpecUdp{}
			}
		} else {
			*(*NetworkACLRuleSpecUdp)(ptr) = NetworkACLRuleSpecUdp{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NetworkACLRuleSpecUdp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkACLRuleSpecUdp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NetworkACLRuleSpecUdp)(ptr) = obj
		} else {
			*(*NetworkACLRuleSpecUdp)(ptr) = NetworkACLRuleSpecUdp{}
		}
	default:
		iter.ReportError("decode NetworkACLRuleSpecUdp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityGroupRuleSpecIcmpCodec struct {
}

func (SecurityGroupRuleSpecIcmpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityGroupRuleSpecIcmp)(ptr) == nil
}

func (SecurityGroupRuleSpecIcmpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityGroupRuleSpecIcmp)(ptr)
	var objs []SecurityGroupRuleSpecIcmp
	if obj != nil {
		objs = []SecurityGroupRuleSpecIcmp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecIcmp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityGroupRuleSpecIcmpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityGroupRuleSpecIcmp)(ptr) = SecurityGroupRuleSpecIcmp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityGroupRuleSpecIcmp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecIcmp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityGroupRuleSpecIcmp)(ptr) = objs[0]
			} else {
				*(*SecurityGroupRuleSpecIcmp)(ptr) = SecurityGroupRuleSpecIcmp{}
			}
		} else {
			*(*SecurityGroupRuleSpecIcmp)(ptr) = SecurityGroupRuleSpecIcmp{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityGroupRuleSpecIcmp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecIcmp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityGroupRuleSpecIcmp)(ptr) = obj
		} else {
			*(*SecurityGroupRuleSpecIcmp)(ptr) = SecurityGroupRuleSpecIcmp{}
		}
	default:
		iter.ReportError("decode SecurityGroupRuleSpecIcmp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityGroupRuleSpecTcpCodec struct {
}

func (SecurityGroupRuleSpecTcpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityGroupRuleSpecTcp)(ptr) == nil
}

func (SecurityGroupRuleSpecTcpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityGroupRuleSpecTcp)(ptr)
	var objs []SecurityGroupRuleSpecTcp
	if obj != nil {
		objs = []SecurityGroupRuleSpecTcp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecTcp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityGroupRuleSpecTcpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityGroupRuleSpecTcp)(ptr) = SecurityGroupRuleSpecTcp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityGroupRuleSpecTcp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecTcp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityGroupRuleSpecTcp)(ptr) = objs[0]
			} else {
				*(*SecurityGroupRuleSpecTcp)(ptr) = SecurityGroupRuleSpecTcp{}
			}
		} else {
			*(*SecurityGroupRuleSpecTcp)(ptr) = SecurityGroupRuleSpecTcp{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityGroupRuleSpecTcp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecTcp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityGroupRuleSpecTcp)(ptr) = obj
		} else {
			*(*SecurityGroupRuleSpecTcp)(ptr) = SecurityGroupRuleSpecTcp{}
		}
	default:
		iter.ReportError("decode SecurityGroupRuleSpecTcp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityGroupRuleSpecUdpCodec struct {
}

func (SecurityGroupRuleSpecUdpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityGroupRuleSpecUdp)(ptr) == nil
}

func (SecurityGroupRuleSpecUdpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityGroupRuleSpecUdp)(ptr)
	var objs []SecurityGroupRuleSpecUdp
	if obj != nil {
		objs = []SecurityGroupRuleSpecUdp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecUdp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityGroupRuleSpecUdpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityGroupRuleSpecUdp)(ptr) = SecurityGroupRuleSpecUdp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityGroupRuleSpecUdp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecUdp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityGroupRuleSpecUdp)(ptr) = objs[0]
			} else {
				*(*SecurityGroupRuleSpecUdp)(ptr) = SecurityGroupRuleSpecUdp{}
			}
		} else {
			*(*SecurityGroupRuleSpecUdp)(ptr) = SecurityGroupRuleSpecUdp{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj SecurityGroupRuleSpecUdp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityGroupRuleSpecUdp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*SecurityGroupRuleSpecUdp)(ptr) = obj
		} else {
			*(*SecurityGroupRuleSpecUdp)(ptr) = SecurityGroupRuleSpecUdp{}
		}
	default:
		iter.ReportError("decode SecurityGroupRuleSpecUdp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualEndpointGatewaySpecTargetCodec struct {
}

func (VirtualEndpointGatewaySpecTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualEndpointGatewaySpecTarget)(ptr) == nil
}

func (VirtualEndpointGatewaySpecTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualEndpointGatewaySpecTarget)(ptr)
	var objs []VirtualEndpointGatewaySpecTarget
	if obj != nil {
		objs = []VirtualEndpointGatewaySpecTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualEndpointGatewaySpecTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualEndpointGatewaySpecTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualEndpointGatewaySpecTarget)(ptr) = VirtualEndpointGatewaySpecTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualEndpointGatewaySpecTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualEndpointGatewaySpecTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualEndpointGatewaySpecTarget)(ptr) = objs[0]
			} else {
				*(*VirtualEndpointGatewaySpecTarget)(ptr) = VirtualEndpointGatewaySpecTarget{}
			}
		} else {
			*(*VirtualEndpointGatewaySpecTarget)(ptr) = VirtualEndpointGatewaySpecTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj VirtualEndpointGatewaySpecTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualEndpointGatewaySpecTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*VirtualEndpointGatewaySpecTarget)(ptr) = obj
		} else {
			*(*VirtualEndpointGatewaySpecTarget)(ptr) = VirtualEndpointGatewaySpecTarget{}
		}
	default:
		iter.ReportError("decode VirtualEndpointGatewaySpecTarget", "unexpected JSON type")
	}
}
