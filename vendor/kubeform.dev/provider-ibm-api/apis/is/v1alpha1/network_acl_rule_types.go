/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type NetworkACLRule struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NetworkACLRuleSpec   `json:"spec,omitempty"`
	Status            NetworkACLRuleStatus `json:"status,omitempty"`
}

type NetworkACLRuleSpecIcmp struct {
	// The ICMP traffic code to allow. Valid values from 0 to 255.
	// +optional
	Code *int64 `json:"code,omitempty" tf:"code"`
	// The ICMP traffic type to allow. Valid values from 0 to 254.
	// +optional
	Type *int64 `json:"type,omitempty" tf:"type"`
}

type NetworkACLRuleSpecTcp struct {
	// The highest port in the range of ports to be matched
	// +optional
	PortMax *int64 `json:"portMax,omitempty" tf:"port_max"`
	// The lowest port in the range of ports to be matched
	// +optional
	PortMin *int64 `json:"portMin,omitempty" tf:"port_min"`
	// The highest port in the range of ports to be matched
	// +optional
	SourcePortMax *int64 `json:"sourcePortMax,omitempty" tf:"source_port_max"`
	// The lowest port in the range of ports to be matched
	// +optional
	SourcePortMin *int64 `json:"sourcePortMin,omitempty" tf:"source_port_min"`
}

type NetworkACLRuleSpecUdp struct {
	// The highest port in the range of ports to be matched
	// +optional
	PortMax *int64 `json:"portMax,omitempty" tf:"port_max"`
	// The lowest port in the range of ports to be matched
	// +optional
	PortMin *int64 `json:"portMin,omitempty" tf:"port_min"`
	// The highest port in the range of ports to be matched
	// +optional
	SourcePortMax *int64 `json:"sourcePortMax,omitempty" tf:"source_port_max"`
	// The lowest port in the range of ports to be matched
	// +optional
	SourcePortMin *int64 `json:"sourcePortMin,omitempty" tf:"source_port_min"`
}

type NetworkACLRuleSpec struct {
	State *NetworkACLRuleSpecResource `json:"state,omitempty" tf:"-"`

	Resource NetworkACLRuleSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`
}

type NetworkACLRuleSpecResource struct {
	Timeouts *base.ResourceTimeout `json:"timeouts,omitempty" tf:"timeouts"`

	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// Whether to allow or deny matching traffic
	Action *string `json:"action" tf:"action"`
	// The rule that this rule is immediately before. If absent, this is the last rule.
	// +optional
	Before *string `json:"before,omitempty" tf:"before"`
	// The destination CIDR block. The CIDR block 0.0.0.0/0 applies to all addresses.
	Destination *string `json:"destination" tf:"destination"`
	// Direction of traffic to enforce, either inbound or outbound
	Direction *string `json:"direction" tf:"direction"`
	// The url of the rule.
	// +optional
	Href *string `json:"href,omitempty" tf:"href"`
	// +optional
	Icmp *NetworkACLRuleSpecIcmp `json:"icmp,omitempty" tf:"icmp"`
	// The IP version for this rule.
	// +optional
	IpVersion *string `json:"ipVersion,omitempty" tf:"ip_version"`
	// The user-defined name for this rule. Names must be unique within the network ACL the rule resides in. If unspecified, the name will be a hyphenated list of randomly-selected words.
	// +optional
	Name *string `json:"name,omitempty" tf:"name"`
	// Network ACL id
	NetworkACL *string `json:"networkACL" tf:"network_acl"`
	// The protocol of the rule.
	// +optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol"`
	// The network acl rule id.
	// +optional
	RuleID *string `json:"ruleID,omitempty" tf:"rule_id"`
	// The source CIDR block. The CIDR block 0.0.0.0/0 applies to all addresses.
	Source *string `json:"source" tf:"source"`
	// +optional
	Tcp *NetworkACLRuleSpecTcp `json:"tcp,omitempty" tf:"tcp"`
	// +optional
	Udp *NetworkACLRuleSpecUdp `json:"udp,omitempty" tf:"udp"`
}

type NetworkACLRuleStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// NetworkACLRuleList is a list of NetworkACLRules
type NetworkACLRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of NetworkACLRule CRD objects
	Items []NetworkACLRule `json:"items,omitempty"`
}
